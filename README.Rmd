---
title: "hyspdisp"
author: "Lucas Henneman"
date: "3/9/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# ```hyspdisp```

```hyspdisp``` is an R package that runs HYSPLIT (https://ready.arl.noaa.gov/HYSPLIT.php) many times. The results can then be aggregated to ZIP code level to create national estimates of exposure from various sources.  For example, plumes from several power plants can be tracked for many days and cummulative impacts estimated. The package relies on a modified version of the ```SplitR``` package, originally developed by https://github.com/rich-iannone/SplitR.

This example walks through an example run of ```hyspdisp``` functions.

# ```hyspdisp``` workflow
### install ```hyspdisp``` from github and load 
First, install ```SplitR```, an R interface to HYSPLIT. ```hysplit``` uses ```SplitR``` to access HYSPLIT.
```{r}
devtools::install_github("lhenneman/SplitR")
library(SplitR)
```
Next, download and install ```hyspdisp```
```{r}
devtools::install_github("lhenneman/hyspdisp")
library(hyspdisp)
```

### Modeling a plume with HYSPLIT from SplitR
Here we present an example of a single emissions event (i.e., a "puff") emitted from one source on 1 January, 2005 at midnight. You can track a single emissions puff of 100 particles emitted in a single hour. These commands are adapted from [SplitR](https://github.com/rich-iannone/SplitR). 

Define species parameters using utility function - two ooptions, so2 and so4
```{r}
species_param <- define_species( "so2")
```

Define an example unit
```{r}
data(units2005)
unit <- units2005[1,]
```

Define run and emissions parameters
- four start hours throughout the day (```start_hour = c( 0, 6, 12, 18)```)
- over 2 days starting on 1 January, 2005
- for emission durations of 1 hour (```duration_emiss_hours = 1```)
- air parcels tracked for 10 hours after emission (```duration_run_hours = 10```)
```{r}
## combine dates and hours
date_ref_h <- data.table( expand.grid( start_hour = c( 0, 6, 12, 18),
                                       start_day = vec_dates <- seq.Date( from = "2005-01-01",
                                                                          length.out = 2,
                                                                          by = '1 day'),
                                       duration_emiss_hours = 1,
                                       duration_run_hours = 10))
```


The ZIP code linkage procedure requires a ZCTA-to-ZIP code Crosswalk file. ZCTAs are not exact geographic matches to ZIP codes, and multiple groups compile and maintain Crosswalk files. One example is the Crosswalk mainted by UDS Mapper. It can be retrieved and its names changed for consistency with ```hyspdisp``` functions with the following commands:
```{r}
library( openxlsx)
crosswalk <- data.table( read.xlsx( xlsxFile = "https://www.udsmapper.org/docs/zip_to_zcta_2017.xlsx"))
setnames( crosswalk, 
          old = "ZIP_CODE", 
          new = "ZIP")
```

Equally important is the ZCTA shapefile. These are available from multiple locations, including the US census website: \url{http://www2.census.gov/geo/tiger/GENZ2017/shp/cb_2017_us_zcta510_500k.zip}. Download the file, unzip it, and read in the shapefile:
```{r}
zcta_shapefile <- "SHAPE_FILE_PATH/cb_2015_us_zcta510_500k.shp"
zcta <- shapefile( x = zcta_shapefile)
```

It is recommended to transform the ZCTA shapefile to a known projection to maintain consistency throughout the allocation process. Lat-lon projections are preferred, such as the [North American Albers Equal Area Conic](https://epsg.io/102008):
```{r}
p4s <- "+proj=aea +lat_1=20 +lat_2=60 +lat_0=40 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m"
zcta2 <- spTransform( x = zcta, 
                      CRSobs = p4s)
```

The final input file is the monthly mean boundary layer heights from [NOAA's Earth System Research Library](https://www.esrl.noaa.gov/psd/data/gridded/data.20thC_ReanV2.monolevel.mm.html)

```{r}
hpbl_file <- "./hpbl.mon.mean.nc"
download.file( url = "ftp://ftp.cdc.noaa.gov/Datasets/20thC_ReanV2/Monthlies/gaussian/monolevel/hpbl.mon.mean.nc",
               destfile = hpbl_file)
hpbl_rasterin <- rotate( brick( x = hpbl_file, 
                                varname = 'hpbl' ))
```

The following code will run HYSPLIT for 100 parcels for each emissions event (```npart = 100```), apply the appropriate trimming (i.e., after a parcel reaches 0m elevation and for parcels that exceed the boundary layer), and calculate ZIP code concentrations. The results and intermediate files will be saved in the current directory or as specified by ```prc_dir```.

```{r}
l <- mclapply( seq_len( nrow( date_ref_h)),
               hyspdisp_fac_model,
               date_ref_h = date_ref_h,
               unit = unit,
               species_param = species_param,
               npart = 100,
               zcta2 = zcta2,
               crosswalk = crosswalk,
               hpbl_raster = hpbl_rasterin,
               link2zip = T)
```

```{r}
dispersion_model <-
  create_disp_model() %>%
  add_emissions(
    rate = 1,
    duration = 1,
    start_day = "2005-01-01",
    start_hour = 0) %>%
  add_species(
    name = species_param$name,
    pdiam = species_param$pdiam, 
    density = species_param$density, 
    shape_factor = species_param$shape_factor, 
    ddep_vel = species_param$ddep_vel) %>% 
  add_grid(
    range = c(0.5, 0.5),
    division = c(0.1, 0.1)) %>%
  add_params(
    lat = unit$Latitude,
    lon = unit$Longitude,
    height = unit$Height,
    duration = 24,
    start_day = "2005-01-01",
    start_hour = 0,
    direction = "forward",
    met_type = "reanalysis"
  ) %>%
  run_model(npart = 100)
```

```{r}
dispersion_df <-
  dispersion_model %>% get_output_df() %>% data.table()
```

## trim particles if they go below zero
disp_df <- trim_zero(dispersion_df)

## Add parcel date and time
disp_df$Pdate <- date_ref$start_day + disp_df$hour / 24

# trims particles that are above the global max boundary value
disp_df_trim <- disp_df[height <= max( values( hpbl_raster))]




## define species parameters
species_param <- define_species( species)

```




























